* 函数的递归调用
函数的调用实际是压栈和出栈的过程，对于需要压栈多次的算法，可以用函数递归来实现。
在现实生活中，递归的方法更象是分治法。
** 函数的递归举例
#include <stdio.h>
#define N 3
#define I 2
//2的3次方
int b[8][N];
int a[N];
void fr(int n)
{
	int i=0;
 static int j=0;
  for(i=0; i<I; i++)
  {	  
   if(n == 0)
  {   int k =0;
      for (k=0; k<N; k++)
	  {  b[j][k] = a[k]; 
              printf("%d -", a[k] );
	  }
	  printf("\n");
	  j++;
	return;
  }
   a[N-n] = i;
   fr(n-1); 
 
  }

}
main()
{
	int c,d;
 fr(N);
 for( c=0; c< 8; c++)
 { printf("===========");
	 for ( d=0; d<N; d++)
		 printf ("%d ",b[c][d]);
 }
}
=====================================
这个例子给出了排列组合的所有情形。这里a[N]记录了一次压栈的完整过程，b记录了所有的数据组合形式。
如果需要先探底到栈底，可以把a[N]放到fr(n-1)后面。这个算法也适应于下棋的穷举法。

* 排序
冒泡排序

冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。它通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。它是O(n^2)的算法。

template <class T>
void bubble_sort( T a[], int n )
{ // 稳定的排序

    // 交换标志exchanged,我们希望用这个标志减少不必要的扫描.
    // 当它为真时,表明交换之前数组无序,但我们也不能确保在交换之后数组每一个
    // 元素都排到有序状态下的正确位置了,所以再对数组进行扫描是必要的.
    // 当它为假时,表明数组有序了,不必再对数组进行扫描了.
    bool exchange = true; // 算法开始前,自然假设数组无序
    for( int i = n - 1; i > 0 && exchange; --i ) { // 最多做n-1趟扫描
        exchange = false; // 在一趟扫描开始前,我们总假设这趟扫描是不必要的
        for( int j = 0; j < i; ++j ) { // 对当前无序区a[0:i]进行扫描
            if( a[j+1] < a[j] ) {
                std::swap( a[j+1], a[j] ); // 大的往下沉,而小的往上冒
                exchange = true; // 发生了交换,故将交换标志置为真
            }
        }
    }
}
选择排序
template <class T>
void selection_sort( T a[], int n )
{ // 不稳定; 反例: { 2, 2, 1 }
    int min;
    for( int i = 0; i < n - 1; ++i ) { // 最多做n-1趟排序
        min = i; // 先假设a[i]最小
        for( int j = i + 1; j < n; ++j ) // 在当前无序区a[i:n-1]中查找最小值
            if( a[j] < a[min] )
                min = j; // min记下当前无序区最小值所在位置
        if( min != i ) // 找到比当前a[i]更小者
            std::swap( a[i], a[min] );
    }
}

效率差不多吧，选择排序的查找和交换过程跟冒泡的次数差不多的吧

冒泡排序是每一次都可能要交换
而选择排序是在比较时记下a[i]的位置 最后来交换 
 所以他们的交换过程是不一样的 而查找的过程是一样的
效率不会比冒泡的低...


  快速排序

快速排序是一个就地排序，分而治之，大规模递归的算法。从本质上来说，它是归并排序的就地版本。快速排序可以由下面四步组成。

（1） 如果不多于1个数据，直接返回。
（2） 一般选择序列最左边的值作为支点数据。
（3） 将序列分成2部分，一部分都大于支点数据，另外一部分都小于支点数据。
（4） 对两边利用递归排序数列。

快速排序比大部分排序算法都要快。尽管我们可以在某些特殊的情况下写出比快速排序快的算法，但是就通常情况而言，没有比它更快的了。快速排序是递归的，对于内存非常有限的机器来说，它不是一个好的选择。
 
  归并排序

归并排序先分解要排序的序列，从1分成2，2分成4，依次分解，当分解到只有1个一组的时候，就可以排序这些分组，然后依次合并回原来的序列中，这样就可以排序所有数据。合并排序比堆排序稍微快一点，但是需要比堆排序多一倍的内存空间，因为它需要一个额外的数组。
 
   堆排序

堆排序适合于数据量非常大的场合（百万数据）。

堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。

堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。
 
   希尔排序

Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。平均效率是O(nlogn)。其中分组的合理性会对算法产生重要的影响。现在多用D.E.Knuth的分组方法。

Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。

  插入排序

插入排序通过把序列中的值插入一个已经排序好的序列中，直到该序列的结束。插入排序是对冒泡排序的改进。它比冒泡排序快2倍。一般不用在数据大于1000的场合下使用插入排序，或者重复排序超过200数据项的序列。

  交换排序和选择排序

这两种排序方法都是交换方法的排序算法，效率都是 O(n2)。在实际应用中处于和冒泡排序基本相同的地位。它们只是排序算法发展的初级阶段，在实际中使用较少。

最常见的排序当然是冒泡排序
**  快速排序
快速排序的思想就是在一个数的集合中随意挑选一个基准数，把所有比它大的数放在左边，把所有比它小的数放在右边。
其实快速排序是利用一趟排序的时间，把这个基准数放在相应的位置，实际是挑出这个数在有序数列中的正确位置。
然后以这个位置为界，左边和右边的集合再进行一次快排。

*** C++，递归快排（非随机）
　　#include<iostream> 　　using namespace std; 　　int a[10001]; 　
　void qs(int s,int e) 
　　{ 　　int x=a[s],l=s,r=e;//以第一个数为参照做比较 
　　if(l>=r)return; 　
　while(l<r) 
　　{ 　　while(l<r&&a[r]>=x) 　　r--; //不小于分界值的留在右边，遇到小于的停止 　
          　a[l]=a[r]; 　
        　while(l<r&&a[l]<=x) 　　l++;//小于分界值的留在左边，遇到不小于的停止 　
    　a[r]=a[l]; 　　} 　
     　a[r]=x; 
 　　qs(s,r-1); 
   　　qs(r+1,e);//递归 　
　} 　
　int main() 　　{ 　　int i,n; 　　cin>>n; //输入要排序的数组元素个数即 数组长度 　
　for(i=0;i<n;i++) 　　cin>>a[i]; //输入数组元素 　　qs(0,n-1); //执行排序函数
 　　for(i=0;i<n;i++) //输出排序后结果 　　cout<<a[i]; 　　system("pause"); 　　}


*** C++，快排（函数）
　　void qs(int s,int e) 
　　{ 　　int x=a[s],l=s,r=e;//以第一个数为参照做比较  int tmp;
　　if(l>=r)return; 　
　while(l<r) 
　　{ 　
     　if(a[r]>=x) 　
         　r--; //不小于分界值的留在右边，遇到小于的停止 　
      else if(a[l]<=x) 　
        　l++;//小于分界值的留在左边，遇到不小于的停止 　
      else {    
           tmp = a[r];
         　a[r]=a[l];
            a[l] =tmp;
            }
 　　} 
      a[l] = a[r];　
     　a[r]=x;
 
      
 　　qs(s,r-1); 
   　　qs(r+1,e);//递归 　
   　} 　

* data structure
** 队列
FIFO
循环队列
** stack
后进先出
** 数组，链表
** 二叉树
二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现 

*** 一、基本概念
 
每个结点最多有两棵子树，左子树和右子树，次序不可以颠倒。
 
性质：
 
1、非空二叉树的第n层上至多有2^(n-1)个元素。
 
2、深度为h的二叉树至多有2^h-1个结点。
 
满二叉树：所有终端都在同一层次，且非终端结点的度数为2。
 

在满二叉树中若其深度为h，则其所包含的结点数必为2^h-1。
 
完全二叉树：除了最大的层次即成为一颗满二叉树且层次最大那层所有的结点均向左靠齐，即集中在左面的位置上，不能有空位置。
 

对于完全二叉树，设一个结点为i则其父节点为i/2，2i为左子节点，2i+1为右子节点。
 
*** 二、存储结构

顺序存储：
将数据结构存在一块固定的数组中。
 
[cpp] view plaincopyprint?
01.#define LENGTH 100  
02.typedef char datatype;  
03.typedef struct node{  
04.    datatype data;  
05.    int lchild,rchild;  
06.    int parent;  
07.}Node;  
08.  
09.Node tree[LENGTH];  
10.int length;  
11.int root;  
 

   虽然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。
 
链式存储：

[cpp] view plaincopyprint?
01.typedef char datatype;  
02.  
03.typedef struct BinNode{  
04.    datatype data;  
05.    struct BinNode* lchild;  
06.    struct BinNode* rchild;  
07.}BinNode;  
08.  
09.typedef BinNode* bintree;          //bintree本身是个指向结点的指针  
 

*** 三、二叉树的遍历


遍历即将树的所有结点访问且仅访问一次。按照根节点位置的不同分为前序遍历，中序遍历，后序遍历。

前序遍历：根节点->左子树->右子树
 
中序遍历：左子树->根节点->右子树
 
后序遍历：左子树->右子树->根节点
 
例如：求下面树的三种遍历
 
        a
      /    \
     b      c
    /    \
   d      f
    \    /
     e  g
 

前序遍历：abdefgc
 
中序遍历：debgfac
 
后序遍历：edgfbca
 
*** 四、遍历的实现
递归实现(以前序遍历为例，其他的只是输出的位置稍有不同)

[cpp] view plaincopyprint?
01.void preorder(bintree t){  
02.    if(t){  
03.        printf("%c ",t->data);  
04.        preorder(t->lchild);  
05.        preorder(t->rchild);  
06.    }  
07.}  
 

非递归的实现
因为当遍历过根节点之后还要回来，所以必须将其存起来。考虑到后进先出的特点，选用栈存储。数量确定，以顺序栈存储。

[cpp] view plaincopyprint?
01.#define SIZE 100  
02.typedef struct seqstack{  
03.    bintree data[SIZE];  
04.    int tag[SIZE];   //为后续遍历准备的  
05.    int top;     //top为数组的下标  
06.}seqstack;  
07.  
08.void push(seqstack *s,bintree t){  
09.  
10.    if(s->top == SIZE){  
11.        printf("the stack is full\n");  
12.    }else{  
13.        s->top++;  
14.        s->data[s->top]=t;  
15.    }  
16.}  
17.  
18.bintree pop(seqstack *s){  
19.    if(s->top == -1){  
20.        return NULL;  
21.    }else{  
22.        s->top--;  
23.        return s->data[s->top+1];  
24.    }  
25.}  
 
**** 1、前序遍历 
[cpp] view plaincopyprint?
01.void preorder_dev(bintree t){  
02.    seqstack s;  
03.    s.top = -1;     //因为top在这里表示了数组中的位置，所以空为-1  
04.    if(!t){  
05.        printf("the tree is empty\n");  
06.    }else{  
07.        while(t || s.stop != -1){  
08.            while(t){    //只要结点不为空就应该入栈保存，与其左右结点无关      
09.                  printf("%c ",t->data);  
10.                push(&s,t);  
11.                t= t->lchild;  
12.            }  
13.            t=pop(&s);  
14.            t=t->rchild;  
15.        }  
16.    }  
17.}  
 



****  2、中序遍历
 [cpp] view plaincopyprint?
01.void midorder(bintree t){  
02.    seqstack s;  
03.    s.top = -1;  
04.    if(!t){  
05.        printf("the tree is empty!\n");  
06.    }else{  
07.        while(t ||s.top != -1){  
08.            while(t){  
09.                push(&s,t);  
10.                t= t->lchild;  
11.            }  
12.            t=pop(&s);  
13.            printf("%c ",t->data);  
14.            t=t->rchild;  
15.        }  
16.    }  
17.}  
 
 
**** 3、后序遍历
 因为后序遍历最后还要要访问根结点一次，所以要访问根结点两次。采取夹标志位的方法解决这个问题。
 这段代码非常纠结，对自己有信心的朋友可以尝试独立写一下。反正我是写了很长时间。逻辑不难，我画了一张逻辑图：
 
 代码：
 

[cpp] view plaincopyprint?
01.void postorder_dev(bintree t){  
02.    seqstack s;  
03.    s.top = -1;  
04.    if(!t){  
05.        printf("the tree is empty!\n");  
06.    }else{  
07.        while(t || s.top != -1){    //栈空了的同时t也为空。  
08.            while(t){  
09.                push(&s,t);  
10.                s.tag[s.top] = 0;   //设置访问标记，0为第一次访问，1为第二次访问  
11.                t= t->lchild;  
12.            }  
13.            if(s.tag[s.top] == 0){  //第一次访问时，转向同层右结点  
14.                t= s.data[s.top];   //左走到底时t是为空的，必须有这步！  
15.                s.tag[s.top]=1;       
16.                t=t->rchild;  
17.            }else {  
18.                while (s.tag[s.top] == 1){ //找到栈中下一个第一次访问的结点，退出循环时并没有pop所以为其左子结点  
19.                    t = pop(&s);  
20.                    printf("%c ",t->data);  
21.                }  
22.                t = NULL; //必须将t置空。跳过向左走，直接向右走  
23.            }  
24.        }  
25.    }  
26.}  
 

 4、层次遍历：即每一层从左向右输出
 

元素需要储存有先进先出的特性，所以选用队列存储。
 
队列的定义：
 


[cpp] view plaincopyprint?
01.#define MAX 1000  
02.  
03.typedef struct seqqueue{  
04.    bintree data[MAX];  
05.    int front;  
06.    int rear;  
07.}seqqueue;  
08.  
09.  
10.void enter(seqqueue *q,bintree t){  
11.    if(q->rear == MAX){  
12.        printf("the queue is full!\n");  
13.    }else{  
14.        q->data[q->rear] = t;  
15.        q->rear++;  
16.    }  
17.}  
18.  
19.bintree del(seqqueue *q){  
20.    if(q->front == q->rear){  
21.        return NULL;  
22.    }else{  
23.        q->front++;  
24.        return q->data[q->front-1];  
25.    }  
26.}  
 

遍历实现 
 


[cpp] view plaincopyprint?
01.void level_tree(bintree t){  
02.    seqqueue q;  
03.    bintree temp;  
04.    q.front = q.rear = 0;  
05.    if(!t){  
06.        printf("the tree is empty\n");  
07.        return ;  
08.    }  
09.    enter(&q,t);  
10.    while(q.front != q.rear){  
11.        t=del(&q);  
12.        printf("%c ",t->data);  
13.        if(t->lchild){  
14.            enter(&q,t->lchild);  
15.        }  
16.        if(t->rchild){  
17.            enter(&q,t->rchild);  
18.        }  
19.    }  
20.}  
 

 
 
5、利用前序遍历的结果生成二叉树
 


[cpp] view plaincopyprint?
01.//递归调用，不存点，想的时候只关注于一个点，因为还会回来的，不要跟踪程序运行，否则容易多加循环  
02.  
03.void createtree(bintree *t){        
04.    datatype c;  
05.    if((c=getchar()) == '#')  
06.        *t = NULL;  
07.    else{  
08.        *t = (bintree)malloc(sizeof(BinNode));  
09.        (*t)->data = c;  
10.        createtree(&(*t)->lchild);  
11.        createtree(&(*t)->rchild);  
12.    }  
13.}  
 

6、二叉树的查找
 


[cpp] view plaincopyprint?
01.bintree search_tree(bintree t,datatype x){  
02.    if(!t){  
03.        return NULL;  
04.    }  
05.    if(t->data == x){  
06.        return t;  
07.    }else{  
08.        if(!search_tree(t->lchild,x)){  
09.            return search_tree(t->rchild,x);  
10.        }  
11.        return t;  
12.    }  
13.}  
 

7、统计结点个数
 


[cpp] view plaincopyprint?
01.int count_tree(bintree t){  
02.    if(t){  
03.        return (count_tree(t->lchild)+count_tree(t->rchild)+1);  
04.    }  
05.    return 0;  
06.}  
 

8、比较两个树是否相同
 


[cpp] view plaincopyprint?
01.int is_equal(bintree t1,bintree t2){  
02.    if(!t1 && !t2){      //都为空就相等  
03.        return 1;  
04.    }  
05.    if(t1 && t2 && t1->data == t2->data){      //有一个为空或数据不同就不判断了  
06.        if(is_equal(t1->lchild,t2->lchild))  
07.            if(is_equal(t1->rchild,t2->rchild)){  
08.                return 1;  
09.            }  
10.    }  
11.    return 0;  
12.}  
 

9、求二叉树的深度
 


[cpp] view plaincopyprint?
01.int hight_tree(bintree t){  
02.    int h,left,right;  
03.    if(!t){  
04.        return 0;  
05.    }  
06.    left = hight_tree(t->lchild);  
07.    right = hight_tree(t->rchild);  
08.    h = (left>right?left:right)+1;  
09.    return h;  
10.}  
 

 
 

.

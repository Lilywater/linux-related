* Android完全编译


http://blog.csdn.net/HKjinzhao/archive/2009/03/18/4002326.aspx

/**
版本：1.0
日期：2009-03-18
作者：HKjinzhao
备注：初始版本
*/
/**
版本：1.1
日期：2009-03-27
作者：HKjinzhao
备注：增加make sdk，修改一些内容
*/

本次编译过程主要参考官方文档（http://source.android.com/download）和网上相关资料（如http://blog.csdn.net/liaoshengjiong/archive/2009/03/04/3957749.aspx）

编译环境：Ubuntu8.10

1、安装一些环境
 sudo apt-get install build-essential
 sudo apt-get install make
 sudo apt-get install gcc
 sudo apt-get install g++
 sudo apt-get install libc6-dev
 
 sudo apt-get install patch
 sudo apt-get install texinfo
 sudo apt-get install libncurses-dev
 
 sudo apt-get install git-core gnupg
 sudo apt-get install flex bison gperf libsdl-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl
 sudo apt-get install ncurses-dev
 sudo apt-get install zlib1g-dev
 sudo apt-get install valgrind
 sudo apt-get install python2.5

安装java环境
sudo apt-get install sun-java6-jre sun-java6-plugin sun-java6-fonts sun-java6-jdk

注：官方文档说如果用sun-java6-jdk可出问题，得要用sun-java5-jdk。经测试发现，如果仅仅make（make不包括make sdk），用sun-java6-jdk是没有问题的。而make sdk，就会有问题，严格来说是在make doc出问题，它需要的javadoc版本为1.5。
因此，我们安装完sun-java6-jdk后最好再安装sun-java5-jdk，或者只安装sun-java5-jdk。这里sun-java6-jdk和sun-java5-jdk都安装，并只修改javadoc.1.gz和 javadoc。因为只有这两个是make sdk用到的。这样的话，除了javadoc工具是用1.5版本，其它均用1.6版本：
sudo apt-get install sun-java5-jdk
修改javadoc的link
cd /etc/alternatives
sudo rm javadoc.1.gz
sudo ln -s /usr/lib/jvm/java-1.5.0-sun/man/man1/javadoc.1.gz javadoc.1.gz
sudo rm javadoc
sudo ln -s /usr/lib/jvm/java-1.5.0-sun/bin/javadoc javadoc

2、设置环境变量
vim ~/.bashrc
在.bashrc中新增或整合PATH变量，如下

#java 程序开发/运行的一些环境变量
JAVA_HOME=/usr/lib/jvm/java-6-sun
JRE_HOME=${JAVA_HOME}/jre
export ANDROID_JAVA_HOME=$JAVA_HOME
export CLASSPATH=.:${JAVA_HOME}/lib:$JRE_HOME/lib:$CLASSPATH
export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin
export JAVA_HOME;
export JRE_HOME;
export CLASSPATH;
HOME_BIN=~/bin/
export PATH=${PATH}:${JAVA_PATH}:${JRE_PATH}:${HOME_BIN};
#echo $PATH;

最后，同步这些变化：
source ~/.bashrc

3、安装repo（用来更新android源码）
创建~/bin目录，用来存放repo程序，如下：
$ cd ~
$ mkdir bin
并加到环境变量PATH中，在第2步中已经加入
下载repo脚本并使其可执行：
$ curl http://android.git.kernel.org/repo >~/bin/repo
$ chmod a+x ~/bin/repo

4、下载 android源码并更新之
建议不要用repo来下载（android源码超过1G，非常慢），直接在网上下载http://www.androidin.com/bbs/pub /cupcake.tar.gz。而且解压出来的 cupcake下也有.repo文件夹，可以通过repo sync来更新cupcake代码：
tar -xvf  cupcake.tar.gz

repo sync（更新很慢，用了3个小时）

5、编译android源码,并得到~/project/android/cupcake/out 目录
进入android源码目录：
make
这一过程很久（2个多小时）

6、在模拟器上运行编译好android

android SDK的emulator程序在android-sdk-linux_x86-1.0_r2/tools/下，emulator是需要加载一些image 的，默认加载android-sdk-linux_x86-1.0_r2/tools/lib/images下的kernel-qemu（内核） ramdisk.img  system.img  userdata.img

编译好android之后，emulator 在~/project/android/cupcake/out/host/linux-x86/bin下， ramdisk.img  system.img  userdata.img则在~/project/android/cupcake/out/target/product/generic下
cd ~/project/android/cupcake/out/host/linux-x86/bin

增加环境变量
vim ~/.bashrc
在.bashrc中新增环境变量，如下
#java 程序开发/运行的一些环境变量
export ANDROID_PRODUCT_OUT=~/project/android/cupcake2/out/target/product/generic
ANDROID_PRODUCT_OUT_BIN=~/project/android/cupcake2/out/host/linux-x86/bin
export PATH=${PATH}:${ANDROID_PRODUCT_OUT_BIN};

最后，同步这些变化：
source ~/.bashrc

emulator -image system.img -data userdata.img -ramdisk ramdisk.img
最后进入android桌面，就说明成功了。
out/host/linux-x86/bin下生成许多有用工具（包括android SDK/tools的所有工具），因此，可以把eclipse中android SDK的路径指定到out/host/linux-x86/bin进行开发

7、编译linux kernel
直接make android源码时，并没有make linux kernel。因此是在运行模拟器，所以不用编译 linux kernel。如果要移值android，或增删驱动，则需要编译 linux kernel
linux kernel的编译将在以后的文章中介绍。

8、编译模块
android中的一个应用程序可以单独编译，编译后要重新生成system.img
在源码目录下执行
. build/envsetup.sh （.后面有空格）
就多出一些命令：
- croot:   Changes directory to the top of the tree.
- m:       Makes from the top of the tree.
- mm:      Builds all of the modules in the current directory.
- mmm:     Builds all of the modules in the supplied directories.
- cgrep:   Greps on all local C/C++ files.
- jgrep:   Greps on all local Java files.
- resgrep: Greps on all local res/*.xml files.
- godir:   Go to the directory containing a file.
可以加—help查看用法
我们可以使用mmm来编译指定目录的模块，如编译联系人：
 mmm packages/apps/Contacts/
编完之后生成两个文件：
out/target/product/generic/data/app/ContactsTests.apk
out/target/product/generic/system/app/ Contacts.apk
可以使用make snod重新生成system.img
再运行模拟器

9、编译SDK
直接执行make是不包括make sdk的。make sdk用来生成SDK，这样，我们就可以用与源码同步的SDK来开发 android了。

1）修改/frameworks/base/include/utils/Asset.h
‘UNCOMPRESS_DATA_MAX = 1 * 1024 * 1024’ 改为 ‘UNCOMPRESS_DATA_MAX = 2 * 1024 * 1024’
原因是Eclipse编译工程需要大于1.3M的buffer

2）编译ADT。
注意，我们是先执行2），再执行3）。因为在执行./build_server.sh时，会把生成的SDK清除了。
用上了新的源码，adt这个调试工具也得自己来生成，步骤如下：
进入cupcake源码的development/tools/eclipse/scripts目录，执行：
export ECLIPSE_HOME=你的eclipse路径
./build_server.sh 你想放ADT的路径

3）执行make sdk。
注意，这里需要的javadoc版本为1.5，所以你需要在步骤1中同时安装sun-java5-jdk
make sdk
编译很慢。编译后生成的SDK存放在out/host/linux-x86/sdk/，此目录下有android-sdk_eng.xxx_linux- x86.zip和android-sdk_eng.xxx_linux-x86目录。android-sdk_eng.xxx_linux-x86就是 SDK目录
实际上，当用mmm命令编译模块时，一样会把SDK的输出文件清除，因此，最好把android-sdk_eng.xxx_linux-x86移出来

4）关于环境变量、android工具的选择
目前的android工具有：
A、我们从网上下载的SDK（ tools下有许多android工具，lib/images下有img映像）
B、我们用make sdk编译出来的SDK（ tools下也有许多android工具，lib/images下有img映像）
C、我们用make编译出来的out目录（ tools下也有许多android工具，lib/images下有img映像）
那么我们应该用那些工具和img呢？
首先，我们不会用A选项的工具和img，因为一般来说它比较旧，也源码不同步。测试发现，如果使用B选项的工具和img，android模拟器窗口变小（可能是skin加载不了），而用C选项的工具和img则不会有此问题。
有些android工具依赖android.jar（比如android），因此，我们在eclipse中使用B选项的工具（SDK），使用C选项的 img。其实，从emulator -help-build-images也可以看出，ANDROID_PRODUCT_OUT是指向C选项的img目录的
不过，除了用A选项的工具和img，用B或C的模拟器都不能加载sdcard，原因还不清楚。

5）安装、配置ADT
安装、配置ADT请参考官方文档

6）创建Android Virtual Device
编译出来的SDK是没有AVD（Android Virtual Device）的，我们可以通过android工具查看：
android list
输出为：
Available Android targets:
[1] Android 1.5
     API level: 3
     Skins: HVGA-P, QVGA-L, HVGA-L, HVGA (default), QVGA-P
Available Android Virtual Devices:
表明没有AVD。如果没有AVD，eclipse编译工程时会出错（Failed to find a AVD compatible with target 'Android 1.5'. Launch aborted.）
创建AVD：
android create avd -t 1 -c ~/sdcard.img -n myavd
可以android –help来查看上面命令选项的用法。创建中有一些选项，默认就行了
再执行android list，可以看到AVD存放的位置
以后每次运行emulator都要加-avd myavd或@myavd选项，这里eclipse才会在你打开的emulator中调试程序


注意：
这样，SDK和ADT就生成了，就按照官方文档把他们整合到Eclipse，这里不再细说了。
建个android的新工程，试试你自己编译的sdk。


* Android Building System 分析

http://www.codemud.net/~thinker/GinGin_CGI.py/show_id_doc/393
Android Building System 分析
by thinker
2 Columns
關鍵字:
Android coding
想要了解一個系統，我常會從 makefile 或是 building system 下手，以了解系統組成元素為何? 目錄結構為何? 對於 Android ，我也不例外。透過了解 building system ，我們能知道如何新增、修改、刪除程式，並保有完整性，順利編譯出結果。

設定檔

Android building system 包括幾種重要的設定檔，

    * Android.mk
    * AndroidProducts.mk
    * target_<os>-<arch>.mk, host_<os>-<arch>.mk and <os>-<arch>.mk
    * BoardConfig.mk
    * buildspec.mk 

Android.mk 是 module 和 package 的設定檔，每個 module/package 的目錄下都會有一個 Android.mk。所謂的 module 是指系統的 native code ，相對於用 Java 寫成的 Android application 稱為 package。

AndroidProducts.mk 則設定 product 配置。 product 即特定系統版本，透過編譯不同 product ，產生不同軟體配置內容，安裝不同的 application。 Product 可視為特定專案，產生特定規格系統。

BoardConfig.mk 是為 product 主板做設定，像是 driver 選擇、設定。*<os>-<arch>.mk 則是針對選擇的作業系統和 CPU 架構，進行相關設定。

buildspec.mk 是位於 source 根目錄下，為進行編譯者所做之額外設定。例如，可在此選擇要產生的 product 、平台、額外的 module/package 等。

參數

build/envsetup.sh 實作一個 mm 指令，以編譯單一 module，不需編譯整個 source tree。ONE_SHOT_MAKEFILE 這個 makefile 變數/參數就是用以實作這個功能。使用方法是在執行 make 時，將該變數指定為 module 的 Android.mk。

    * make ONE_SHOT_MAKEFILE=<path to Androiod.mk> 

透過定義 CREATE_MODULE_INFO_FILE ， building system 會將所有 module 資訊列在 $(PRODUCT_OUT)/module-info.txt 檔案裡。

    * make CREATE_MODULE_INFO_FILE=true 

設定 BUILD_TINY_ANDROID=true ， building system 產生一個簡單的 image ，以測試硬體的可用度。此功能用於移植的早期階段，以快速 bring up 。

HOST_BUILD_TYPE 和 TARGET_BUILD_TYPE 指定 building system 產生 binary 的目的為 debug 或 release 。透過設定此二變數，能產生包含 debug information 的 binry 。

    * debug
    * release 

這些參數，也可設於 buildspec.mk 裡，以避免開發過程不斷的重新指定。

Goals

一般編輯整個 Android 系統，就是使用 droid 這個 goal。 droid 會產生一個完整的系統，包括 bootloader、kernel、系統程式、模組和應用程式。

showcommands 和 droid 功能相同，但 droid 在編譯過程不顯示所使用的指令。透過 showcommands 這個 goal， building system 顯示過程中每一個步驟的詳細指令。

Makefile 的流程

    * 初始化相關變數
    * 偵測編譯環境和目標環境
    * 決定目標 product
    * 讀取 product 的設定
    * 讀取 product 所指定之目標平台架構設定
          o 選擇 toolchain
          o 指定編譯參數 (*<os>-<arch>.mk) 
    * 清除輸出目錄
    * 設定/檢查版本編號
    * 讀取所有 BoardConfig.mk 檔案
    * 讀取所有 module 的設定
    * 根據設定，產生必需的 rule
    * 產生 image 

以上的主要流程都是由 build/core/main.mk 所安排。

初始化和偵測

由 build/core/config.mk 所進行。 build/core/envsetup.mk 檢查 developer 的設定 (buildspec.mk) ，並檢查執行環境，以決定輸出目錄、項目。

build/core/config.mk 本身還依據參數，決定解譯時的相關參數。像是 compiler 的路徑、flags， lex 、yacc 的路徑參數等。

關於 product 的相關設定，則是由 build/core/product_config.mk 所處理，使用 build/core/product.mk 提供之 macro 載入。根據 AndroidProduct.mk 的內容， product_config.mk 決定了

    * PRODUCT_TAGS
    * OTA_PUBLIC_KEYS
    * PRODUCT_POLICY
    * ...... 

Product 設定的讀取

Android product 的設定來自於 build/target/product/AndroidProduct.mk 和 vendor 子目錄下的 AndroidProduct.mk 。 building system 透過 find 指令，找出所有可能的 AndroidProduct.mk。 AndroidProduct.mk 裡定義 PRODUCT_MAKEFILES 變數，列舉所有實際定義 product 的 makefile。這些 makefile 各自定義獨立的 product 。product 相關參數，存成 PRODUCTS.<path of makefile>.<variable> 形式的變數。並將 makefile 路徑存在 PRODUCTS 變數。因此，透過 PRODUCTS 能取得所有的 product 路徑/名稱，並透過 PRODUCTS.<path of makefile>.<variable> 形式的變數取得內容。

Module 設定的讀取

Module 是指 native code 的軟體元件，而 Java application 則被稱為 package。 build/core/definitions.mk 定義 module/package 相關 macro ，讀取、檢查 module/package 定義檔；分散 source tree 各處的 Android.mk 檔案。 build/core/main.mk 使用 find 指令，在這些子目錄下找出所有 Android.mk ，並將路徑存在 subdir_makefiles 變數裡。最後，include 這些檔案。

這些 Android.mk 會 include 定義成變數 BUILD_SHARED_LIBRARY 、BUILD_PACKAGE 等，和其目的相配的 makefile。這些 makefile 會變 Android.mk 定義之內容，存成 ALL_MODULES.<path of Android.mk>.<variable> 形式。例如， Android.mk 定義了 LOCAL_MODULE_SUFFIX ，變會存成 ALL_MODULES.<path of Android.mk>.LOCAL_MODULE_SUFFIX 。而 Android.mk 路徑，當樣會存於 ALL_MODULES 變數裡。

Search Android.mk 的路徑，基本上會是整個 source tree 。但會依特定的 goal ，選擇性只找尋特定目錄。例如 SDK 只需特定目錄下的 Android.mk 。

Board Level 設定

和目標平台主板相關之設定，例如使用了什麼裝置、driver 等，或是是否需要編譯 bootloader 、 kernel 等，都是在 BoardConfig.mk 裡設定。同樣，每張主板可以有不同設定，存在不同目錄下的 BoardConfig.mk ，以 find 尋找如下檔案:

    * build/target/board/$(TARGET_DEVICE)/BoardConfig.mk
    * vendor/*/$(TARGET_DEVICE)/BoardConfig.mk 

TARGET_DEVICE 是 product 所定義，因此同一個 BoardConfig.mk 可被多個 product 所使用。一個 TARGET_DEVICE ，通常只有一個 BoardConfig.mk 。 BoardConfig.mk 會被直接 include 到 building system 的 name space 裡。因此，一些 module 的 enable/disable ，可以在 BoardConfig.mk 以對映不同的主板。

Rules

在 module 的定義檔 Android.mk 裡，可定義 module 的 tag， LOCAL_MODULE_TAGS，以分類這些 module。每一個 product 可以指定需要的 tag (PRODUCT_TAGS)，使 building system 只編譯標示這些 tag 的 module。在 build/core/main.mk 裡，所有標示特定 tag 的 module 收集為 ALL_DEFAULT_INSTALLED_MODULES ，並 include build/core/Makefile 處理。

build/core/Makefile 為這些 module 產生 rule ，並使產生 image 的 goal depend on 這些 rule ，使這些 module 被編譯。

結論

Android 的 building system 其實不是那麼複雜。在了解之後，也不是那麼難修改。但， GNU make 的一些語法，所 building system 使用一些不是那麼直覺的用法，使的 building system 較難了解。但，花點心思就能克服。 

* Android编译系统分析和使用

自带帮助文件
file:///home/zxx/Android-2.2/build/core/build-system.html
http://mmmyddd.freeshell.net/wiki/android/build.html


android-1.5最顶层的目录结构如下：
.
|-- Makefile        （全局的Makefile）
|-- bionic          （Bionic含义为仿生，这里面是一些基础的库的源代码）
|-- bootloader      （引导加载器）
|-- build           （build目录中的内容不是目标所用的代码，而是编译和配置所需要的脚本和工具）
|-- dalvik          （JAVA虚拟机）
|-- development     （程序开发所需要的模板和工具）
|-- external        （目标机器使用的一些库）
|-- frameworks      （应用程序的框架层）
|-- hardware        （与硬件相关的库）
|-- kernel          （Linux2.6的源代码）
|-- packages        （Android的各种应用程序）
|-- prebuilt        （Android在各种平台下编译的预置脚本）
|-- recovery        （与目标的恢复功能相关）
`-- system          （Android的底层的一些库）
黄色的好像没下到

Makefile 的分析：
在源代码根目录下的Makefile
include build/core/main.mk
                   |
include build/core/config.mk


make环境的分析：
build/envsetup.sh
这是一个需要source的shell文件，在命令行里应该是
source build/envsetup.sh
.   build/envsetup.sh
这两条命令是相同的。
但是
./build/envsetup.sh
sh ./build/envsetup.sh
又不同.
区别在于  source的文件后，所有function都可以当作命令输入其中，而后者只是shell执行的则不可以。

showcommands 
显示命令的执行， 一般命令前家@就会不显示此条命令。
如果把@变为可控的，就可以控制是否输出：
main.mk
--------------------------------------------
.PHONY: showcommands
showcommands:
	@echo >/dev/null
--------------------------------

definitions.mk
--------------------------------------------------------------------
###########################################################
## Output the command lines, or not
###########################################################

ifeq ($(strip $(SHOW_COMMANDS)),)
define pretty
@echo $1
endef
3~
hide := @
else
define pretty
endef
hide :=
endif
------------------------------------------------------------------------
$(hide) $(ACP) -fp $(CTS_HOST_JAR) $(PRIVATE_DIR)/tools
使用时hide放在命令行前就可以控制此条命令的执行时是否显示
所以用make showcommands编译就可以显示命令了。


MAKECMDGOALS
这是makefile默认的内置变量
The MAKECMDGOALS variable contains a list of all the targets specified on the command line for the current execution of make. It does not include command-line options or variable assignments. For instance:

$ make -f- FOO=bar -k goal <<< 'goal:;# $(MAKECMDGOALS)'
相当于
-----------------------------------------
goal:
	# $(MAKECMDGOALS)
------------------------------
# goal
参数 -f -k, 赋值 FOO=bar are not included in MAKECMDGOALS

The example uses the "trick" of telling make to read the makefile from the stdin with the -f- (or —file) option. The stdin is redirected from a command-line string using bash's here string, "<<<", syntax.[3] The makefile itself consists of the default goal goal, while the command script is given on the same line by separating the target from the command with a semicolon. The command script contains the single line:

    [3] For those of you who want to run this type of example in another shell, use:

# $(MAKECMDGOALS)


MAKECMDGOALS is typically used when a target requires special handling. The primary example is the "clean" target. When invoking "clean," make should not perform the usual dependency file generation triggered by include (discussed in Section 2.7 in Chapter 2). To prevent this use ifneq and MAKECMDGOALS:

ifneq "$(MAKECMDGOALS)" "clean"

  -include $(subst .xml,.d,$(xml_src))

endif


a single module to compile
main.mk
-----------------------------------------------------------------------------------------------------
ifneq ($(ONE_SHOT_MAKEFILE),)
# We've probably been invoked by the "mm" shell function
# with a subdirectory's makefile.
include $(ONE_SHOT_MAKEFILE)
# Change CUSTOM_MODULES to include only modules that were
# defined by this makefile; this will install all of those
# modules as a side-effect.  Do this after including ONE_SHOT_MAKEFILE
# so that the modules will be installed in the same place they
# would have been with a normal make.
CUSTOM_MODULES := $(sort $(call get-tagged-modules,$(ALL_MODULE_TAGS)))
FULL_BUILD :=
# Stub out the notice targets, which probably aren't defined
# when using ONE_SHOT_MAKEFILE.
NOTICE-HOST-%: ;
NOTICE-TARGET-%: ;

else # ONE_SHOT_MAKEFILE

#
# Include all of the makefiles in the system
#

# Can't use first-makefiles-under here because
# --mindepth=2 makes the prunes not work.
subdir_makefiles := \
	$(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)

include $(subdir_makefiles)
endif # ONE_SHOT_MAKEFILE
-----------------------------------------------------------------------------------------------------
这样可以在顶层 make <mymodulename> 来只编译一个单独的模块
make 時，將該變數指定為 module 的 Android.mk。

• make ONE_SHOT_MAKEFILE=<path to Androiod.mk> 


a default target in top level
if there's a buildspec.mk in top level, make will depend on this file,
---------
# Choose a variant to build.  If you don't pick one, the default is eng.
# User is what we ship.  Userdebug is that, with a few flags turned on
# for debugging.  Eng has lots of extra tools for development.
ifndef TARGET_BUILD_VARIANT
#TARGET_BUILD_VARIANT:=user
#TARGET_BUILD_VARIANT:=userdebug
#TARGET_BUILD_VARIANT:=eng
endif
--------------------------------------
if there's not buildspec.mk in top dir, then source envsetup.sh to set the build enviorment
envsetup.sh
-----------------------------------------
if [ "$selection" = "simulator" ]
    then
        export TARGET_PRODUCT=sim
        export TARGET_BUILD_VARIANT=eng
        export TARGET_SIMULATOR=true
        export TARGET_BUILD_TYPE=debug
-----------------------------------------------

编译的配置
--------------------------------------------------
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.2.1
TARGET_PRODUCT=generic
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=FRG83
------------------------------

parameter of make
./build/core/Makefile
# -----------------------------------------------------------------
# module info file
ifdef CREATE_MODULE_INFO_FILE
  MODULE_INFO_FILE := $(PRODUCT_OUT)/module-info.txt
  $(info Generating $(MODULE_INFO_FILE)...)
  $(shell rm -f $(MODULE_INFO_FILE))
  $(foreach m,$(ALL_MODULES), \
    $(shell echo "NAME=\"$(m)\"" \
	"PATH=\"$(strip $(ALL_MODULES.$(m).PATH))\"" \
	"TAGS=\"$(strip $(filter-out _%,$(ALL_MODULES.$(m).TAGS)))\"" \
	"BUILT=\"$(strip $(ALL_MODULES.$(m).BUILT))\"" \
	"INSTALLED=\"$(strip $(ALL_MODULES.$(m).INSTALLED))\"" >> $(MODULE_INFO_FILE)))
endif
--------------------------------------------------
make CREATE_MODULE_INFO_FILE=true

./build/core/main.mk
----------------------------------------------
else	# !SDK_ONLY
ifeq ($(BUILD_TINY_ANDROID), true)

# TINY_ANDROID is a super-minimal build configuration, handy for board 
# bringup and very low level debugging

subdirs := \
	bionic \
	system/core \
	build/libs \
	build/target \
	build/tools/acp \
	build/tools/apriori \
	build/tools/kcm \
	build/tools/soslim \
	external/elfcopy \
	external/elfutils \
	external/yaffs2 \
	external/zlib
---------------------------------------------------------------------------
make BUILD_TINY_ANDROID=true


make 時，將該變數指定為 module 的 Android.mk。

    * make ONE_SHOT_MAKEFILE=<path to Androiod.mk> 
*  Android 编译问题

代码下载 问题 ：
下载Google的Android操作系统的时候卡在下面一步：

 

 

我遇到的情况是 errno=connection refused

Getting repo ...
   from git://android.git.kernel.org/tools/repo.git
android.git.kernel.org[0: 204.152.191.45]: errno=Connection timed out
android.git.kernel.org[0: 130.239.17.12]: errno=Connection timed out
android.git.kernel.org[0: 149.20.20.141]: errno=Connection timed out
android.git.kernel.org[0: 199.6.1.176]: errno=Connection timed out
fatal: unable to connect a socket (Connection timed out)

找各种原因，可能是公司用的局域网ISP将Git的端口9418给封了，因为http://android.git.kernel.org是可以访问的。后来搜了一下知道很多git服务器同时提供端口80的下载。解决方法如下：

1.将命令行中的git://android.git.kernel.org换成http://android.git.kernel.org，

2.修改文件repo将里面的

REPO_URL='git://android.git.kernel.org/tools/repo.git' 改成

REPO_URL='http://android.git.kernel.org/tools/repo.git'

3. 修改文件.repo/manifests/default.xml将其中的 fetch="git://android.git.kernel.org/" 改成

fetch="http://android.git.kernel.org/"

这样就可以下载同步Android的源代码了
---------------------------------------------------------------------
步骤：

http://web.nchu.edu.tw/~jlu/cyut/android/build22.shtml

~/bin/repo init -u git://android.git.kernel.org/platform/manifest.git -b android-2.2.1_r1


（以下的步驟絕大部分都是在 Ubuntu/Linux 上執行）


   2. 在編譯 AOSP 原始碼之前，我們必須先安裝一些套件。這些步驟主要是參考 dferreira 發表的 [HOW-TO] Compile AOSP Froyo + [ROM] Latest AOSP Froyo for Sapphire。
         1. 在 /etc/apt/sources.list 檔案的最後加上下列兩行：

              deb http://pl.archive.ubuntu.com/ubuntu/ jaunty multiverse
              deb http://pl.archive.ubuntu.com/ubuntu/ jaunty universe
              

         2. 檔案修改完後，請執行下列指令來該新 apt 的資料庫：

              sudo apt-get update
              

         3. 請執行下列指令（只有一行）來安裝必要的軟體：

              sudo apt-get install git-core gnupg sun-java5-jdk flex bison gperf libsdl-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl libncurses5-dev zlib1g-dev valgrind libreadline5-dev gcc-multilib g++-multilib libc6-dev libncurses5-dev x11proto-core-dev libx11-dev libreadline5-dev libz-dev
              

         4. 請在自己的家目錄（$HOME）底下新增一個 bin 目錄，並將 repo 安裝到 bin 內。安裝後可以登出然後登入，剛安裝的 repo 就可以開始使用。

              cd ~
              mkdir bin
              curl http://android.git.kernel.org/repo >~/bin/repo
              chmod a+x ~/bin/repo
              

         5. 決定 AOSP 原始碼放置的目錄，並建立該目錄。假設目錄的名稱是 froyo，且位於 $HOME，以下為執行並進入 froyo 目錄：

              mkdir ~/froyo
              cd ~/froyo
              

   3. 軟硬體的環境設定好了之後，我們就開始要從 AOSP 的網站把原始碼抓下來。
         1. 由於 Android 的版本眾多，你必須定義出究竟是哪一個版本是你要的。由於我們參考的 文件是編譯 Android 2.2 版的，因此我們的指令如下：

            repo init -u git://android.git.kernel.org/platform/manifest.git -b android-2.2.1_r1

            請特別注意以上指令的綠色部分：因為編譯的是 Android 2.2.1 版的，所以我們使用 android-2.2.1_r1，那麼如果有一天我要編譯 3.0 版呢？它的值應該是什麼呢？其實，這個資料可以從 http://android.git.kernel.org/ 的網頁上找尋 platform/manifest.git，然後在它之後的 summary 連結上點一下，就可以知道。在 http://android.git.kernel.org/?p=platform/manifest.git;a=summary 網頁的下方的 tags 部分就可以看到所有可能的值。

         2. 執行 repo sync 把定義好的原始碼抓回來，這個可能會等待比較久的時間。 

   4. 編譯 kernel 以及無線網路的驅動程式。就像在 把玩"魔術師" -- 編譯 AOSP 2.1 (Eclair) 原始碼 所說的，如果你能找到適當的 kernel 和 wlan.ko，那麼這個步驟可以省略。其實使用正確的 kernel 版本很重要，但是哪一版的 Android 應該配合哪一版的 kernel 呢？目前在網路上看到的情形是 "如果使用 Android x.x 版，但是 kernel 比較舊的 y.y 版，那麼一些新的功能是無法執行的"；所以從以上的圖片可以看出，HTC 的 kernel 是 2.6.27 版，而 Android 是 2.2，所以應該會有一些 2.2 的功能無法發揮。為了能夠編譯正確版本的 kernel，找到了 Wiki 上的 Android (operating system) 的列表，我把它整理如下：
          * Android 1.5 (Cupcake): Kernel 2.6.27
          * Android 1.6 (Donut): Kernel 2.6.29
          * Android 2.0/2.1 (Eclair): Kernel 2.6.29
          * Android 2.2 (Froyo): Kernel 2.6.32 

            作法一： 如果可能，請儘可能使用相同硬體，而且也已經編譯好的 kernel 和 wlan.ko。目前為止，總共有幾個現成的 kernel，分別是：
                o Rogers 給 HTC Magic 2.1 版的 ROM。（作法請參考 把玩"魔術師" -- 幫 boot.img 換 kernel）
                o Android 1.5 版的 Running Android AOSP on HTC Magic 32A Phones 的 "32A patch"。 

            作法二： 自行編譯 kernel；目前使用 Old Radio（3.22 版）的有 CM 的 kernel，以及使用 New Radio（6.35 版）的 HTC 的 kernel。編譯 HTC kernel 的方式請參考 把玩"魔術師" -- 編譯 HTC Kernel 原始碼。 

   5. 把新編譯的 kernel 和無線網路的驅動程式複製到適當的位置 -- ~/froyo/device/htc/dream-sapphire/。指令為

        cp ~/froyo/kernel/arch/arm/boot/zImage ~/froyo/device/htc/dream-sapphire/kernel
        cp ~/froyo/system/wlan/ti/sta_dk_4_0_4_32/wlan.ko ~/froyo/device/htc/dream-sapphire/wlan.ko
        

   6. 請在 device/htc/dream-sapphire/BoardConfigCommon.mk 的第 49 行之後，新增一行在產生 boot.img 所需要的 base address 給 32A 的手機用，修改後，第 49 和 50 行設定如下：

        BBOARD_KERNEL_CMDLINE := no_console_suspend=1 console=null
        BOARD_KERNEL_BASE := 19200000
        

   7. 將專屬於 HTC Magic 手機的重要的程式庫納入 system.img。這些程式庫必須存在才能順利的編譯 Android，但是由於抓取的（或者說 HTC 提供的）都已經是舊版的（明確的說是 1.6 版），所以常常造成編譯出來的 image 檔雖然能夠在手機上執行，但是也造成許多程式（如之前提到的 Calendar 和 Music 等）無法順利執行的原因。

         1. 取得 HTC 的檔案，並解壓縮。抓取並解壓縮檔案的指令為

              wget --referer=http://developer.htc.com/google-io-device.html http://member.america.htc.com/download/RomCode/ADP/signed-google_ion-ota-14721.zip?
              mv signed-google_ion-ota-14721.zip sapphire_update.zip
              cd ~/froyo/device/htc/sapphire
              ./unzip-files.sh
              

            重要更新： 由於加拿大電信商 Rogers 以及美國電信商 T-Mobile 分別釋出了 Android 2.1 以及 2.2 （前者有 Sense UI，後者就是陽春的 Google UI；這可能是因為目前的更新是針對 32B 的手機，而該手機的記憶體有限所致），所以以上的 sapphire_update.zip 可以使用不同的來源。
                * 若使用 Rogers 的 2.1 版，可以下載 Rogers stock rom with root，下載後可以將檔案名稱從 Rogers_21_capychimp.zip 改成 sapphire_update.zip 即可。印象中，解出來的檔案只缺一個，也就是 libstagefrighthw.so，所以下一個步驟只需要刪除一行即可。
                * 若使用 T-Mobile 的 2.2.1 版，可以下載 Froyo OTA，下載後可以將檔案名稱從 e059adc603a3.signed-opal-ota-60505.e059adc6.zip 改成 sapphire_update.zip 即可。印象中，所需的檔案都有，因此下一個步驟可以省略。 

         2. 執行 unzip-files.sh 的過程中，總共有四個檔案找不到；這四個檔案分別是 libGLES_qcom.so、liblvmxipc.so、liboemcamera.so、libstagefrighthw.so。請修改 vendor/htc/sapphire/device_sapphire-vendor-blobs.mk 將包含該四個檔案的四行敘述刪除。 

   8. 編譯 Android 平台，編譯成功的話，會產生必要的 image 檔。
         1. 加入繁體以及簡體中文的支援，指令如下：

              cd ~/froyo
              

            並新增 buildspec.mk 檔案，在該檔案內加入

              CUSTOM_LOCALES:=zh_TW zh_CN
              

            在一些蒐集到的資料中，也顯示我們可以直接更改 build/target/product/full.mk，把第 43 行的

              $(call inherit-product, build/target/product/languages_small.mk)
              

            改成

              $(call inherit-product, build/target/product/languages_full.mk)
              

         2. 設定編譯的平台，包含以下指令：

              source build/envsetup.sh
              lunch full_sapphire-userdebug  # 也可以執行 lunch 並選擇平台
              

            lunch 指令後面那一串字包含一些重要資訊，我們把它拆開來看：第一個 aosp 也可以是 full，目前我不清楚它的差異；第二個 sapphire 代表 Magic 32A，可以是 dream，也可以是 generic（代表基本型，僅適用模擬器）；第三個是 us（代表美國），另一個是 eu（代表歐洲）；最後一個是 eng（代表有 root 權限），也可以是 userdebug（代表一般環境）。

         3. 執行 make -j2 編譯 image 檔；這會需要一段時間，完成後在 ~/froyo/out/target/product/sapphire 內可以看到 image 檔。 

   9. 複製必要的字形檔，然後將新的字形檔與之前的結果，重新整理到 system.img 中。

        cp frameworks/base/data/fonts/DroidSansFallback.ttf  out/target/product/sapphire/system/fonts/
        make snod
        


